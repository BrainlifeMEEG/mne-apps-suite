name: App Integration Tests

on:
  push:
    branches: [ master, develop ]
    paths:
      - 'app-*/main.py'
      - 'brainlife_utils/**'
      - '.github/workflows/app-tests.yml'
  pull_request:
    branches: [ master, develop ]

env:
  MNE_SKIP_FS_DIRNAME: 1
  MNE_USE_CUDA: 'no'

jobs:
  detect-changed-apps:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Detect changed apps
      id: set-matrix
      run: |
        # Get list of changed app directories
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
        else
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD || echo "app-*/main.py")
        fi
        
        # Extract unique app directories
        APPS=$(echo "$CHANGED_FILES" | grep -oE "app-[^/]+" | sort -u | jq -R . | jq -s . || echo '[]')
        
        # If no apps detected, include a sample
        if [ "$APPS" = "[]" ]; then
          APPS=$(echo '["app-epoch", "app-ICA-fit"]')
        fi
        
        echo "matrix={\"app\":$(echo "$APPS")}" >> $GITHUB_OUTPUT
        echo "Changed apps: $APPS"

  test-apps:
    needs: detect-changed-apps
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.detect-changed-apps.outputs.matrix)}}
      fail-fast: false
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: 'recursive'
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install MNE and dependencies
      run: |
        python -m pip install --upgrade pip
        pip install mne[data] matplotlib nibabel scipy scikit-learn
    
    - name: Check app structure
      working-directory: ${{ matrix.app }}
      run: |
        # Verify required files exist
        required_files=("main.py" "main" "config.json" "README.md")
        
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "âœ— Missing required file: $file"
            exit 1
          else
            echo "âœ“ Found $file"
          fi
        done
    
    - name: Validate Python syntax
      working-directory: ${{ matrix.app }}
      run: |
        python -m py_compile main.py
        echo "âœ“ main.py syntax is valid"
    
    - name: Check imports
      working-directory: ${{ matrix.app }}
      run: |
        python -c "
        import ast
        import sys
        
        with open('main.py') as f:
            tree = ast.parse(f.read())
        
        imports = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.append(node.module)
        
        print('Detected imports:')
        for imp in sorted(set(imports)):
            print(f'  - {imp}')
        "
    
    - name: Validate config.json
      working-directory: ${{ matrix.app }}
      run: |
        python -c "
        import json
        
        with open('config.json') as f:
            config = json.load(f)
        
        required_keys = ['_app_id', '_app_version', 'inputs', 'outputs']
        for key in required_keys:
            if key not in config:
                print(f'âœ— Missing required key: {key}')
                exit(1)
            print(f'âœ“ Found {key}')
        "
    
    - name: Check brainlife_utils import
      working-directory: ${{ matrix.app }}
      run: |
        # Check if app uses brainlife_utils
        if grep -q "from brainlife_utils" main.py; then
          echo "âœ“ App uses brainlife_utils"
          
          # Verify brainlife_utils is accessible
          python -c "
          import sys
          import os
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'brainlife_utils'))
          sys.path.insert(0, os.path.dirname(os.getcwd()))
          
          try:
              import brainlife_utils
              print(f'âœ“ brainlife_utils module found: {brainlife_utils.__file__}')
          except ImportError as e:
              print(f'âœ— Failed to import brainlife_utils: {e}')
              exit(1)
          "
        else
          echo "âš  App does not use brainlife_utils (may be in refactoring backlog)"
        fi
    
    - name: Dry-run with sample config
      working-directory: ${{ matrix.app }}
      run: |
        # Create a minimal config.json for dry-run
        python -c "
        import json
        import os
        
        # Load existing config
        with open('config.json') as f:
            config = json.load(f)
        
        # Create test config with dummy paths
        test_config = config.copy()
        
        # Set input paths to test files (if they exist)
        for inp in test_config.get('inputs', []):
            if 'datatype' in inp:
                # Create dummy file path
                inp['path'] = f\"test_{inp['name']}.fif\"
        
        print(f'Test config for {os.path.basename(os.getcwd())}:')
        print(json.dumps(test_config, indent=2))
        "
    
    - name: Generate app report
      working-directory: ${{ matrix.app }}
      run: |
        python -c "
        import os
        import json
        
        print(f'ðŸ“¦ App Report: {os.path.basename(os.getcwd())}')
        print('-' * 50)
        
        # Read config
        with open('config.json') as f:
            config = json.load(f)
        
        print(f'App ID: {config.get(\"_app_id\", \"N/A\")}')
        print(f'Version: {config.get(\"_app_version\", \"N/A\")}')
        print(f'Inputs: {len(config.get(\"inputs\", []))}')
        print(f'Outputs: {len(config.get(\"outputs\", []))}')
        
        # Check for README
        if os.path.exists('README.md'):
            with open('README.md') as f:
                lines = len(f.readlines())
            print(f'README: {lines} lines')
        
        # Check main.py
        with open('main.py') as f:
            lines = len(f.readlines())
        print(f'main.py: {lines} lines')
        "

  summary:
    runs-on: ubuntu-latest
    needs: test-apps
    if: always()
    
    steps:
    - name: Workflow status
      run: |
        echo "âœ“ CI workflow completed"
        echo "Tested apps: ${{ needs.detect-changed-apps.outputs.matrix }}"
